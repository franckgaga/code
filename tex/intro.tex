% !TeX encoding = UTF-8
% !TeX spellcheck = en_US
\section{Introduction}

The process control community, both in the academic and industrial sectors, has largely relied on MATLAB toolboxes and commercial solutions for designing, simulating and implementing closed-loop systems \citep{mpcSurvey, optimMatlab}. The ecosystem developed by MathWorks\texttrademark\ is rich, mature, cohesive, and well documented, but their licensing policy can be unaffordable for smaller organizations. Moreover, because it is a proprietary software, the source code of many functions is not available. This is an issue for scientific research, where reproducibility and transparency is a key aspect. Lastly, like any interpreted languages e.g., Python, its performance can be suboptimal for computationally intensive tasks, especially for time-critical applications like real time optimization and model predictive control \citep{matlabPythonJulia, juliaML}.

Julia is relatively new programming language specialized for scientific and numerical computing. The just-ahead-of-time compiler can reach performance comparable to C and Fortran, while exhibiting a modern and expressive syntax like MATLAB and Python \citep{juliaPaper}. The built-in read-eval-print-loop (REPL) allows to interactively test code and inspect variables, mimicking the development workflow of an interpreted language. It also includes a package manager with a general registry, which makes it easy to share, install or update code. Moreover, the environment is free and open-source and it can be used for commercial purposes without any licensing fees. The ecosystem is still young, but a control toolbox (\texttt{ControlSystems.jl}), a system identification (\texttt{ControlSystemIdentification.jl}) and an optimization packages (\texttt{JuMP.jl}) are already available and complete for the most parts \citep{controlsystems, jump}. There is no free and open-source model predictive control (MPC) toolset available yet in the official registry of Julia, which is the main motivation for this project.

This paper presents an MPC package for Julia. The objective is to provide a simple, clear and modular framework to quickly design and test predictive controllers in Julia, while preserving the flexibility for advanced real-time optimization. The focus is on modern MPCs that rely on a closed-loop state observer for the feedback. Traditional approach like internal model structure is also available. The \texttt{JuMP.jl} interface allows changing the solver quickly among  many open-source and commercial optimization software (local and global). As generic Julia functions can be differentiated using forward mode automatic differentiation of \texttt{ForwardDiff.jl}, the gradient, Jacobian and Hessian of the objective/constraint function for nonlinear MPCs are computed automatically with the machine precision. This also applies for the extended Kalman Filter. Additionally, by leveraging the multiple dispatch paradigm, nonlinear
controllers based on linear models (e.g., economic MPC) evaluate the predictions with matrix algebra instead of a \texttt{for} loop, which is generally more efficient especially for the constraint handling. Both soft and hard constraints on inputs, input increments, outputs, and terminal states are supported. 

Linear plant models are automatically augmented with an adequate representation of the unmeasured disturbances based on observability (can be customized). For the nonlinear case, the user chooses to add integrated white noise on the input or output for each channel. The Luenberger observer and all the classical Kalman-type filters are available as feedback strategies. In addition, the analog of predictive control but for state estimation, the moving horizon estimator, will also be available soon after this publication. It will allow adding constraints at estimation.

The next section presents the structure and the main features of the package. The following one present two case studies to illustrate the syntax: a linear and a nonlinear controller design.
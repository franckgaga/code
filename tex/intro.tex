% !TeX encoding = UTF-8
% !TeX spellcheck = en_US
\section{Introduction}

The process control community, both in the academic and industrial sectors, has largely relied on MATLAB toolboxes and commercial solutions for designing, simulating and implementing closed-loop systems \citep{optimMatlab}. The ecosystem developed by MathWorks\texttrademark\ is rich, mature, cohesive, and well documented, but their licensing policy can be unaffordable for smaller organizations. Moreover, because it is a proprietary software, the source code of many functions is not available. This is an issue for scientific research, where reproducibility and transparency is a key aspect. The dependency on a single vendor also raises concerns about the long-term support of third-party control software products. Lastly, like any interpreted languages e.g., Python, its performance can be suboptimal for computationally intensive tasks, especially for time-critical applications like real time optimization and model predictive control \citep{matlabPythonJulia, juliaML}. Code generation mitigates this issue, but it creates other problems like additionnanal licensing fees, the difficulty to debug the generated code, and the restriction to a subset of the language.

Julia is relatively new programming language specialized for scientific and numerical computing. The just-ahead-of-time compiler can reach performance comparable to C and Fortran, while exhibiting a modern and expressive syntax like MATLAB and Python \citep{juliaPaper}. The built-in read-eval-print-loop (REPL) allows to interactively test code and inspect variables, mimicking the development workflow of an interpreted language. It also includes a package manager with a general registry, which makes it easy to share, install or update code. Moreover, the environment is free and open-source and it can be used for commercial purposes without any licensing fees. The ecosystem is still young, but a control toolbox (\texttt{ControlSystems.jl}), a system identification (\texttt{ControlSystemIdentification.jl}) and an optimization (\texttt{JuMP.jl}) packages are already available \citep{controlsystems, jump}. There is no free and open-source model predictive control (MPC) toolset available yet in the official registry of Julia, which is the gap this work fills.

This paper presents an MPC package for Julia. It aims to provide a simple, clear and modular framework to quickly design and test predictive controllers in Julia, while preserving the flexibility for advanced real-time optimization. For now, the package does particularly endeavor for original methodological scientific contributions or bleeding edge technologies like collocation methods, but rather to improve the accessibility to advanced process control, both for the academic and industrial community. With the exception of the petrochemical sector, many facilities still run their processes entirely in open-loop or with simple local controllers \citep{gapMPC}. Advanced process control can significantly reduce the waste in raw material and energy consumption. This is highly needed in the context of climate changes and the increasing scarcity of resources.

It focuses on modern MPCs that rely on a closed-loop state estimator for the feedback. The package currently implements the Luenberger observer and all the classical Kalman-type filters. It also incorporates an internal model control structure, as a more traditionnal approach. In addition, the analog of predictive control but for state estimation, the moving horizon estimator (MHE), is also available to solve constrained estimation problems. The user can also provide its own feedback strategy by defining a new state estimator subtype.

Linear plant models are automatically augmented with an adequate representation of the unmeasured disturbances based on observability (customizable). For the nonlinear case, the user chooses to add integrated white noise on the input or output for each channel. The \texttt{JuMP.jl} interface allows changing the solver quickly among  many open-source and commercial optimization software (local and global). As generic Julia functions can be differentiated using automatic differentiation , the gradient and Jacobian of the objective/constraint function for nonlinear MPCs are computed automatically with the machine precision. This also applies for the extended Kalman Filter. 

Additionally, by leveraging the multiple dispatch paradigm of Julia, nonlinear controllers based on linear models (e.g., economic MPC) evaluate the predictions with matrix algebra instead of a \texttt{for} loop, which is generally more efficient especially for the constraint handling. More precisely, the package functions dispatch on both the types of the controller and the plant model to select the most efficient implementation. Both soft and hard constraints on inputs, input increments, outputs, and terminal states are supported. The MHE state and noise estimates also support constraint relaxation.

The next section presents the structure and the main features of the package. The following one present two case studies to illustrate the syntax and benchmark the performances: a linear and a nonlinear controller design.